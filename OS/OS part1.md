---
title: OS
subtitle: Part 1
author: HanJaehee
presentedAt: 2020-12-08
---

## 운영체제

운영체제(Operating System) : 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어



## 커널

소프트웨어는 컴퓨터에서 실행되기 위해 메모리에 올라가 있어야 한다. 하지만, 운영체제 모두가 올라가기엔 규모가 크므로 항상 필요한 부분만을 올려놓고 나머지는 필요에 따라 올려 실행한다.
여기서 항상 필요한 부분을 커널(Kernel) 이라 한다.

## 역할

	• 컴퓨터 시스템 내의 자원(resource)을 효율적으로 관리
	• 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공- 여러 사용자 또는 프로그램에게 각각 독자적으로 컴퓨터를 사용하는 것과 같은 '환상')- 하드웨어를 직접 다루는 복잡한 부분을 대행해줌

## 분류

동시작업

	• 단일 작업(Single Tasking) : DOS 등 하나의 프로그램이 실행되는 동안 다른 프로그램을 실행시킬 수 있는 명령어 입력 라인이 뜨지 않아 한번에 하나의 작업만을 실행
	• 다중 작업(Multi  tasking) : MS 윈도우, UNIX 등 여러 작업을 동시에 가능- 시분할 시스템(time sharing system) : CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템, 사실 CPU는 한번에 하나의 프로그램만을 처리할 수 있지만, 빠른 처리속도와 시분할을 통해 여러 프로그램이 동시에 실행되는것처럼 보이는 것
		⁃ 다중 프로그래밍 시스템(multi-programming system): 여러 프로그램들을 메모리에 동시에 올려놓고 처리
		⁃ 대화형 시스템(interactive system) : 여러 프로그램을 동시에 실행시키지만, 사용자의 입력에 대해 곧바로 응답하는 시스템
		⁃ 다중 처리기 시스템(multi-processor system) : 하나의 컴퓨터 안에 CPU가 여러개이므로 실제로 동시에 여러 프로그램을 실행시킬 수 있지만, 그만큼 운영체제는 더욱 복잡한 메커니즘을 필요로한다. 다중 사용자 지원 , 단일 사용자용, 다중 사용자용(서버)

작업 처리방식

	• 일괄 처리(Batch processing) : 요청된 작업을 일정량씩 모아 한꺼번에 처리, 일정량이 쌓이면 일괄적으로 처리 후 모든 작업이 끝난 후 결과를 얻을 수 있다. 사용자 입장에선 응답시간이 김
	• 시분할 방식 : 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용, 여러 사용자 작업의 경우 짧은 시간 단위로 번갈아가며 처리해, 평균적으로 사람들이 길다고 느끼는 시간에까지 이르지 않고 응답을 받기 때문에 단독으로 컴퓨터를 사용하는 것 처럼 느낀다. == 대화형 시스템이 시분할 방식의 특징
	• 실시간 방식(real time) : 정해진 시간안에 어떠한 일이 반드시 처리됨을 보장해야하는 시스템, 시간 내에 처리하지 못할 경우 동작 자체가 되지 않거나 큰 위험을 초해라 가능성이 있는 시스템에서 사용(원자로, 공장 제어, 미사일 제어 등)
	• 경성 실시간 시스템(hard realtime) : 주어진 시간을 지키지 못할 경우 매우 위험한 경우(로켓, 원자로 제어 등)
	• 연성 실시간 시스템(soft realtime): 정해진 시간내로 처리해야 올바른 기능을 수행하는 경우 ( 멀티미디어 스트리밍 시스템 등

## 기능


CPU 스케줄링 : CPU를 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않는 것.

	• 선입선출(FCFS, First Come First Served) : 먼저 온것 먼저 처리, 프로세스가 작업 완료 시 까지 다른 프로세스들이 사용 불가
	• 라운드로빈(Round Robin) : CPU를 한번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한
	• 우선순위(Priority) : 우선순위를 통해 CPU를 먼저 획득할 수 있게 함, 기다린 시간이 길수록 우선순위를 높게 해 소외되는 프로세스가 없게 함

메모리 관리 : 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 해야함

	• 고정 분할(Fixed partition) : 물리적 메모리를 몇 개의 분할로 미리 나누어 관리함, 각 파티션에는 하나의 프로그램이 적재됨, 융통성 없음
	• 가변 분할(Variable partition) : 프로그램의 크기에 맞게 할당된다. 하지만, 물리적 메모리의 크기 보다 더 큰 프로그램의 실행은 불가능
	• 가상 메모리(Virtual memory) : 현재 사용됨, 물리적 메모리보다 큰 프로그램이 실행 가능하다. OS 처럼 프로그램에도 필수적으로 항상 실행되어야하는 부분과 그렇지 않은 부분이 있는데, 필수 부분을 올려놓고 그렇지 않은 부분들은 보조기억장치에 저장해두었다가(Swap Area) 필요할 때 적재한다. 이 때 페이지(page) 단위로 물리 메모리와 스왑 영역에 저장된다. == 페이징 기법

인터럽트: 입출력 장치 및 주변 장치가 CPU의 서비스가 필요할 때 발생

	• 인터럽트가 발생하면 CPU는 하던 작업을 멈추고 인터럽트를 발생시킨 장치의 일을 처리한 후 본래의 작업을 이어나간다.
	• 컨트롤러 : 주변 장치들의 작업들을 처리하고, CPU에 인터럽트를 발생시키는 놈
	• 하드웨어 인터럽트 : 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
	• 소프트웨어 인터럽트 : 소프트웨어가 CPU의 인터럽트 라인 세팅
	• 인터럽트 벡터(Interrupt vector) : 인터럽트 종류마다 번호를 지정하고, 번호에 따라 처리할 코드가 위치한 부분을 가리키고 있는 자료구조, 실제 처리해야할 코드는 인터럽트 처리루틴(interrupt service routine), 인터럽트 핸들러(interrupt handler)라고 불리는 다른곳에 저장
	• 인터럽트 핸들링 : 인터럽트가 발생한 경우 처리해야 하는 일의 절차, 인터럽트가 발생하면 현재 실행중인 프로그램의 코드의 메모리주소, 레지스터값, 하드웨어 상태 등을 PCB(Process Control Block)에 담아놓고 인터럽트 처리루틴으로 넘어가고, 처리가 끝나면, PCB로부터 저장된 상태들을 다시 CPU에 복원해 실행된다.
	• 요즘 운영체제들은 인터럽트가 발생할 때에만 실행되며, 이 외에는 사용자 프로그램만이 실행된다. 그래도 자원관리가 잘된다.

입출력구조

	• 동기식 입출력 : 입출력 장치가 입출력을 수행중인 경우는 CPU가 다른 프로그램을 수행할 수 있게 한다. ( 입출력 중인 프로그램의 상태를 봉쇄 상태(blocked state) == 입출력을 수행중인 상태 ) 이 때, 입출력 장치 간 동기성을 보장하기 위해 장치마다 큐를 두고 요청된 순서대로 처리한다. 각 장치의 컨트롤러는 입출력 연산이 완료되면 CPU에게  인터럽트를 통해 알리고,  CPU는 봉쇄상태를 해제시킨다.
	• 비동기식 : 비슷한듯..? 유창아 도와줘

DMA(Direct Memory Access)

	• CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할, 로컬 버퍼에서 메모리로 읽어오는 작업을 DMA가 대행함으로써 CPU는 인터럽트 당할 필요가 없다. 작업이 끝난 후 바이트가 아닌 블록단위로 CPU에 인터럽트를 발생시켜 모든 장치가 CPU에 인터럽트를 발생시키는 빈도를 줄여 자원관리를 효율적으로 하는것

저장장치

	• 주기억장치(메모리) : 휘발성(volatile)
	• 보조기억장치(하드 등) : 비회발성(nonvolatile)
	• 보조기억장치 용도
	• 파일 시스템용 : 전원이 나가도 정보들이 저장될 곳
	• 스왑 영역(swap area)용 : 주기억장치인 메모리의 크기는 상대적으로 비싸고, 용량이 한정적인 경우가 많아 운영체제는 이를 효율적으로 운용하기 위해 프로그램 수행에 필요한 부분들은 메모리에, 그렇지 않은 부분들은 보조기억장치의 스왑 영역에 담아놓는다. == 스왑 아웃(swap out)
	• 계층 구조 : 휘발성 (레지스터, 캐시, 메인 메모리) 이외 비휘발성, 상위 계층일수록 속도 업, 용량 상대적으로 적음

   
하드웨어 보안

	• 다중 프로그래밍 환경에서 각 프로그램이 서로의 영역을 침범하면 안됨. 따라서 커널모드와 사용자모드로 나뉘어 다른 프로그램의 영역에 침범할 수 있는 연산은 커널모드에서, 일반적인 연산들은 사용자모드에서 실행해 보안성을 확보. 
	• 하지만 이렇더라도 사용자모드의 프로그램이 CPU 제어권을 갖고 있는 동안에는 운영체제에게 제어권이 없으므로 통제하지 못하므로 하드웨어 적인 지원을 통해 방지
	• 모드비트(mode bit) : 0 - 커널모드, 1- 사용자모드, 사용자 프로그램에서 하드웨어 접근이 필요한 명령을 실행할 경우 시스템 콜을 통해 운영체제가 대신 해줄것을 요청하고, 이 때 모드 비트가 0으로 변경되어 명령들을 수행한 후 다시 모드 비트를 1로 변경해 사용자프로그램에서 CPU제어권을 넘긴다.
	• 특권명령: 위의 커널 모드 비트를 이용해 실행하는 명령들이 특권명령 ( ex, 입출력 명령 )

메모리 보안

	• C언어 포인터 등 메모리 주소 참조연산을 이용해 악의적인 접근이나 실수로 다른 프로그램이나 운영체제의 메모리 주소를 침범할 수 있음. 이를 기준 레지스터(base register)와 한계 레지스터(limit register)로 방지한다.
    • 이 두 레지스터값을 정하는 건 역시 커널모드만이 가능
	• 이 두 레지스터를 통해 사용자 프로그램이 접근할 수 있는 메모리 영역을 한정한다. 이 외의 메모리에 접근시도할 경우 예외 상황을 발생시켜 운영체제에 소프트웨어 인터럽트를 발생하고, CPU 제어권을 운영체제로 가져오고, 예외발생시킨 프로그램을 강제 종료한다.
    • 하지만, 최근 메모리 관리는 페이징 기법을 이용하므로, 이 방법은 의미가 없다 페이징기법에 대한 보안은 뒤에 나올 예정

CPU 보호

	• 특정 프로그램이 CPU를 독점해 사용하는 것을 방지하기위해 타이머(timer)라는 하드웨어 사용, 정해진 시간이 지나면 인터럽트를 발생시켜 CPU제어권을 가져온다. 이 시간은 load timer 명령어를 통해 세팅되며 특권명령이다. 사실 이게  시분할 시스템이었던 것

시스템 콜을 이용한 입출력 수행

	• 사용자 프로그램이 디스크에 파일을 write, read 등, 키보드, 마우스 입출력, 모니터 출력 등 모두 입출력 명령으로 특권명령사용자 프로그램은 이 특권명령들을 시스템 콜이라는 운영체제에 미리 정의된 명령들을 호출해 운영체제가 대신 실행시키게끔 처리한다.
	• 사용자프로그램이 시스템 콜 -> 입출력 장치 컨트롤러 입출력 수행 -> 수행 완료 시 CPU에 완료 인터럽트 발생 -> 해당 프로그램이 다시 CPU제어권 획득


##  프로그램 구조와 실행

프로그램 구조와 인터럽트

	• 프로그램이 CPU에 의해 실행되기 위해서는 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
	• 프로그램 주소 영역 : 코드, 데이터, 스택
	• 코드 : 프로그램 함수들의 코드가 CPU에서 실행할 기계어 형태로 변환되어 저장되어 있는 영역
	• 데이터 : 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 영역
	• 스택 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 영역
	• 인터럽트도 함수 호출과정과 비슷하지만, 인터럽트는 PCB에 돌아올 주소와 정보를 저장하는 것이 차이점

컴퓨터 시스템의 작동 개요( 3장 내용 반복)

	• Program Counter, PC : CPU가 수행할 메모리 주소를 담고 있는 레지스터
	• 입출력 장치 별로 존재하는 작은 CPU == 입출력 컨트롤러, 메모리 == 로컬 버퍼
	• 인터럽트를 발생시키기 위해 주변장치들은 인터럽트 라인을 세팅하고, CPU는 명령 수행직후 매번 인터럽트 라인을 체크해 서비스요청이 들어와있는지 확인한다.


프로그램의 실행

	• 프로그램이 실행되고 있다 == 디스크에 존재하던 실행파일이 메모리에 적재 되어있다 && 프로그램이 CPU를 할당받고 명령을 수행중이다.
	• 커널의 스택 영역
	• 커널의 스택은 수행중인 프로세스마다 별도의 스택을 두어 관리,  시스템 콜 내에서 다른 함수를 호출하는 경우 복귀 주소는 커널 내 주소가 되기 때문에 별도고 관리한다.
	• 즉, 프로그램은 자기 자신의 코드 내에서 호출 및 복귀를 유지하기 위해 자기 주소 공간내 스택 사용, 시스템 콜 또는 인터럽트 등 운영체제 코드 실행에서의 호출 복귀는 커널 스택을 사용(주의! 사용자 프로그램에서 운영체제로 넘어갈 때는 복귀 정보가 PCB에 저장된다는 점, 이 후의 여러 함수 호출 및 복귀를 뜻하는 것임)

사용자 프로그램이 사용하는 함수 (사용자 정의 함수, 라이브러리 함수 ,커널 함수)

	• 사용자 정의 함수 : 프로그래머가 작성한 코드
	• 라이브러리 함수 : 다른 프로그래머가 작성해놓은 코드
	• 커널 함수 : 운영체제 커널의 코드에 정의된 함수
	• 시스템 콜 함수 : 사용자 프로그램이 운영체제의 서비스 요청하기 위함
	• 인터럽트 함수 : 하드웨어 및 소프트웨어가 CPU서비스를 요청하기 위함
	• 삼각함수 sin() -> 라이브러리, printf() -> 커널함수를 호출하는 시스템콜을 동반하는 라이브러리 함수
	• 일반적인 함수 호출 : 사용자 프로그램 내에 존재하는 코드를 실행하는 것
	• 시스템 콜 : 운영체제에 제어권을 넘겨 실행하는 것(인터럽트와 동일하게 인터럽트 라인 세팅해 호출)

인터럽트

	• 원칙적으론 인터럽트 내에서 인터럽트는 호출되지 않는것이 원칙이지만, 중요도 또는 우선순위에 따라 처리하는 경우도 있다.

시스템 콜

	• 프로그램이 명령어를 수행하다 CPU 제어권을 뻇기는 경우
	• 타이머에 의한 인터럽트
	• 입출력 요청을 위한 시스템 콜


## 프로세스 관리

프로세스 : 실행 중인 프로그램( In memory)

	• Context : 프로세스가 현재 어떤 상태인지 규명하기 위한 정보
	• 프로세스의 주소공간(코드, 데이터, 스택 상태), 레지스터 정보 등 프로세스의 모든 정보
	• 하드웨어 Context : CPU의 수행 상태, PC(Program Counter), 레지스터 등
	• 프로세스의 주소 공간: 코드, 데이터, 스택 상태
	• 커널상의 문맥 : PCB, 커널 스택
상태

	- 실행, 준비 ,봉쇄
	• 실행(running) : 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태 ( 매 시점 하나뿐 ) 
	• 준비(ready) : 프로세스가 CPU만 보유하면 당장 명령어를 실행할 수 있는 상태, 메모리 보유상태
	• 봉쇄(waiting, blocked) : CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태
	- 시작상태, 종료상태
	• 시작(new) : 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인 받지 못한 상태
	• 종료(termintated) : 프로세스가 종료되었으나 운영체제가 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

문맥교환(Context Switching)

	• 프로세스 변경을 위해 기존 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 저장
	• 타이머 인터럽트, 실행 상태 프로세스의 입출력 요청 등으로 발생
	• CPU 디스패치(dispatch) : 준비상태의 프로세스에 제어권을 넘겨주는 과정
	• 사용자 모드 전환(사용자 <-> 커널) 보다 오버헤드가 크다 ( 시간 )

프로세스 제어 블록(PCB)

	• 프로세스 상태, PC, CPU레지스터 값, CPU 스케줄링 정보, 메모리 관리 정보, 자원 사용 정보, 입출력 상태 정보
	• 프로세스 상태 : CPU를 할당해도 되는지 여부
	• PC : 다음에 수행할 명령어의 위치
	• CPU레지스터 값 : 현 시점에 레지스터에 어떤 값을 저장하고 있는지
	• 입출력 상태 정보 : 프로세스가 오픈한 파일 정보 등 

스케줄링을 위한 큐 

	• CPU 스케줄링 : Part 2에서 자세히
	• 모든 큐는 연결리스트 형태로 저장
	• 준비 큐(ready queue) : 준비 상태인 프로세스 queue
	• 장치(하드웨어) 큐 : 특정 자원을 기다리는 프로세스 queue ex, 디스크 입출력 큐, 키보드 입출력 큐 등
	• 작업 큐(job queue) : 시스템 내의 모든 프로세스를 관리하기 위한 큐( 준비 + 장치 ), 상태와 무관하다.

스케줄러

	• 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드
	• 장기 == 작업 스케줄러 : 어떤 프로세스를 준비 큐에 진입시킬지, 메모리를 보유해야 하므로 메모리 할당 문제 관여
	• 비교적 가끔(수십초, 수분 마다) 호출되어 느린 것이 허용됨
	• 준비 큐 == in memory => 메모리에 동시에 올라가있는 프로세스 조절
	• 최근 운영체제들에 없다 패스해..
	• 단기 == CPU 스케줄러 : 준비 큐 중 어떤 프로세스를 실행할 지 스케줄 ( 시분할에서 타이머 인터럽트 발생시 호출됨)
	• 중기 : 너무 많은 프로세스에게 메모리를 할당해 이를 동적으로 조절하기 위한 스케줄러
	• 너무 많은 프로세스를 적재해 프로세스당 메모리 공간이 적어지면 일부 프로세스들을 스왑 영역에 스왑 아웃 한다.
	• 스왑 0순위 => 봉쇄 상태 프로세스, 1순위 => 타이머 인터럽트에 의해 준비 큐로 넘어가려는 프로세스들
	• 중기 스케줄러에 의해 스왑아웃된  프로세스들의 상태를 '중지(suspended)' 라고 함, 이는 외부에서 재개시키지 않는 이상 다시 활성화 되지 않는다.

프로세스 생성

	• 프로세스가 프로세스를 생성할 수 있는데, 생성한 프로세스를 부모, 생성된 프로세스를 자식으로 칭한다.
	• 자식프로세스들에 대한 처리를 부모가 담당하며, 부모는 모든 후손 프로세스들을 정리해야 종료될 수 있다.
	• 부모자식 공존모델 : CPU를 획득하기 위해 경쟁
	• 자식종료대기 모델: 자식프로세스가 종료될 때까지 부모프로세스는 봉쇄상태, 자식이 종료되면 그때 준비 상태(리눅스, 프롬프트에서 명령어 실행 시 종료될 때까지 프롬프트 다시 안뜸)
	• 자식 프로세스는 부모와 별도의 주소 공간을 갖지만, 처음 공간 생성 시 부모의 주소 공간 내용을 그대로 복사해 생성된다. 즉, 부모 프로세스가 마지막에 실행했던 지점부터 실행된다 ( PC를 그대로 복사해왔기 때문)
	• 생성 절차
	• fork() : 자식 프로세스 생성
	• exec() : 자식 프로세스가 새로운 주소 공간을 덮어 쓰는것
	• exit() : 운영체제에 프로세스 종료 통보, 컴파일러가 알아서 삽입하고 자동 호출됨
	• abort() : 부모가 자식 강제 종료, 1. 자식 프로세스가 자원한계치를 넘어서는 자원을 요구할 때, 2. 자식에 할당된 작업이 필요 없을 때, 3. 부모가 종료될 때
	• wait() : 부모가 wait()을 콜하면 자식 종료를 기다리며 종료되는 순간 준비큐에 진입

프로세스간 협력

	• 원칙적으로 프로세스간 자원 공유( 서로간의 주소 공간 참조 ) 는 불허
	• IPC(Inter-Process Communication) : 프로세스간 통신, 데이터 동기화를 위한 메커니즘
	⁃메시지 전달, 공유 메모리
	• 메시지 전달(message passing) : 공유 데이터를 사용하지 않고 메세지를 주고 받으며 통신, 둘이 직접 통신이 아닌 커널이 중계자로 커널을 통해서만 send, recieve(둘다 특권 명령) 할수 있음
	• 통신을 원하는 두 프로세스는 communication link 생성 후 send와 receive를 통해 통신
	• 직접통신(process to process), 간접 통신 ( process to mailbox or port)
	• 공유 메모리(shared memory) : 주소 공간의 일부를 공유, 사실은 각 프로세스가 독립공간을 유지하고, 동일한 물리공간을 함께 사용하는것, 동기화는 알아서해야함

