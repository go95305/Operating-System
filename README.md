메모리관리
=========

보통 4KB 단위로 묶어서 페이지 라는 하나의 행정구역을 만든다.

총 32 비트의 주소중 하위 12비트는 페이지 내에서의 주소를 나타내게 되는 것.
#
#
#
1.주소 바인딩
----


##### 논리적 주소(가상 주소)

프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성.

##### 물리적 주소

물리적 메모리에 실제로 올라가는 위치.

> CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물맂거 메모리의 어느 위치에 매핑되는지 확인해야 한다. 이렇게 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩( address binding) 이라고 한다.




###### 주소 바인딩 방식

- 컴파일 타임 바인딩
- 로드 타임 바인딩
- 실행시간 바인딩




##### 실행시간 바인딩

CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.

> 기준 레지스터는 재배치 레지스터라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.

MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 **연속적으로 적재**되는 것으로 가정한다.

따라서 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.

MMU 기법에서는 문맥교환으로 CPU에서 수행 중인 프로세스가 바뀔 때마다 재배치 레지스터의 값을 그 프로세스에 해당되는 값으로 재설정함으로써 각 프로세스에 맞는, 서로 다른 100번지 위치에 접근하는 것을 지원.




*고려할 사항?*

> 다중 프로그래밍 환경에서 물리적 메모리 안에는 여러 개의 프로세스가 동시에 올라가 있는 경우가 대부분이다.
>
> 따라서  위의 MMU 방식을 사용하여 주소 변환을 했을 경우 CPU가 요청한 논리적 주속밧과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할 수 있다.
>
> 이것을 방지하기 위해 **한계 레지스터(limit register)**라는 또 하나의 레지스터를 사용.




###### 한계 레지스터

프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용.

현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있다.





2.메모리 관리와 관련된 용어
---


+ [동적로딩](#동적로딩)
+ [동적연결](#동적연결)
+ [중첩](#중첩)
+ [스와핑](#스와핑)



##### 동적로딩

프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 메모리는 좀 더 효율적으로 사용하기 위해 해당 부분이 불릴 때 그 부분만을 메모리에 적재하는 방식.







